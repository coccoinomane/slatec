C
C  slatec_3j_f77.f
C  slatec.git
C
C  This file contains an extract of the huge Slatec library that allows the user
C  to compute just the 3J and 6J Wigner Symbols (which are closely related to the
C  Clebsch-Gordan and Racah W-coefficients, respectively), the Airy functions and
C  the Bessel functions, both regular and spherical.
C
C  The original SLATEC library is hosted on Netlib:
C  http://www.netlib.org/slatec/index.html


*DECK DRC3JJ
      SUBROUTINE DRC3JJ (L2, L3, M2, M3, L1MIN, L1MAX, THRCOF, NDIM,
     +   IER)
C***BEGIN PROLOGUE  DRC3JJ
C***PURPOSE  Evaluate the 3j symbol f(L1) = (  L1   L2 L3)
C                                           (-M2-M3 M2 M3)
C            for all allowed values of L1, the other parameters
C            being held fixed.
C***LIBRARY   SLATEC
C***CATEGORY  C19
C***TYPE      DOUBLE PRECISION (RC3JJ-S, DRC3JJ-D)
C***KEYWORDS  3J COEFFICIENTS, 3J SYMBOLS, CLEBSCH-GORDAN COEFFICIENTS,
C             RACAH COEFFICIENTS, VECTOR ADDITION COEFFICIENTS,
C             WIGNER COEFFICIENTS
C***AUTHOR  Gordon, R. G., Harvard University
C           Schulten, K., Max Planck Institute
C***DESCRIPTION
C
C *Usage:
C
C        DOUBLE PRECISION L2, L3, M2, M3, L1MIN, L1MAX, THRCOF(NDIM)
C        INTEGER NDIM, IER
C
C        CALL DRC3JJ (L2, L3, M2, M3, L1MIN, L1MAX, THRCOF, NDIM, IER)
C
C *Arguments:
C
C     L2 :IN      Parameter in 3j symbol.
C
C     L3 :IN      Parameter in 3j symbol.
C
C     M2 :IN      Parameter in 3j symbol.
C
C     M3 :IN      Parameter in 3j symbol.
C
C     L1MIN :OUT  Smallest allowable L1 in 3j symbol.
C
C     L1MAX :OUT  Largest allowable L1 in 3j symbol.
C
C     THRCOF :OUT Set of 3j coefficients generated by evaluating the
C                 3j symbol for all allowed values of L1.  THRCOF(I)
C                 will contain f(L1MIN+I-1), I=1,2,...,L1MAX+L1MIN+1.
C
C     NDIM :IN    Declared length of THRCOF in calling program.
C
C     IER :OUT    Error flag.
C                 IER=0 No errors.
C                 IER=1 Either L2.LT.ABS(M2) or L3.LT.ABS(M3).
C                 IER=2 Either L2+ABS(M2) or L3+ABS(M3) non-integer.
C                 IER=3 L1MAX-L1MIN not an integer.
C                 IER=4 L1MAX less than L1MIN.
C                 IER=5 NDIM less than L1MAX-L1MIN+1.
C
C *Description:
C
C     Although conventionally the parameters of the vector addition
C  coefficients satisfy certain restrictions, such as being integers
C  or integers plus 1/2, the restrictions imposed on input to this
C  subroutin are somewhat weaker. See, for example, Section 27.9 of
C  Abramowitz and Stegun or Appendix C of Volume II of A. Messiah.
C  The restrictions imposed by this subroutine are
C       1. L2 .GE. ABS(M2) and L3 .GE. ABS(M3);
C       2. L2+ABS(M2) and L3+ABS(M3) must be integers;
C       3. L1MAX-L1MIN must be a non-negative integer, where
C          L1MAX=L2+L3 and L1MIN=MAX(ABS(L2-L3),ABS(M2+M3)).
C  If the conventional restrictions are satisfied, then these
C  restrictions are met.
C
C     The user should be cautious in using input parameters that do
C  not satisfy the conventional restrictions. For example, the
C  the subroutine produces values of
C       f(L1) = ( L1  2.5  5.8)
C               (-0.3 1.5 -1.2)
C  for L1=3.3,4.3,...,8.3 but none of the symmetry properties of the 3j
C  symbol, set forth on page 1056 of Messiah, is satisfied.
C
C     The subroutine generates f(L1MIN), f(L1MIN+1), ..., f(L1MAX)
C  where L1MIN and L1MAX are defined above. The sequence f(L1) is
C  generated by a three-term recurrence algorithm with scaling to
C  control overflow. Both backward and forward recurrence are used to
C  maintain numerical stability. The two recurrence sequences are
C  matched at an interior point and are normalized from the unitary
C  property of 3j coefficients and Wigner's phase convention.
C
C    The algorithm is suited to applications in which large quantum
C  numbers arise, such as in molecular dynamics.
C
C***REFERENCES  1. Abramowitz, M., and Stegun, I. A., Eds., Handbook
C                  of Mathematical Functions with Formulas, Graphs
C                  and Mathematical Tables, NBS Applied Mathematics
C                  Series 55, June 1964 and subsequent printings.
C               2. Messiah, Albert., Quantum Mechanics, Volume II,
C                  North-Holland Publishing Company, 1963.
C               3. Schulten, Klaus and Gordon, Roy G., Exact recursive
C                  evaluation of 3j and 6j coefficients for quantum-
C                  mechanical coupling of angular momenta, J Math
C                  Phys, v 16, no. 10, October 1975, pp. 1961-1970.
C               4. Schulten, Klaus and Gordon, Roy G., Semiclassical
C                  approximations to 3j  and 6j coefficients for
C                  quantum-mechanical coupling of angular momenta,
C                  J Math Phys, v 16, no. 10, October 1975,
C                  pp. 1971-1988.
C               5. Schulten, Klaus and Gordon, Roy G., Recursive
C                  evaluation of 3j and 6j coefficients, Computer
C                  Phys Comm, v 11, 1976, pp. 269-278.
C***ROUTINES CALLED  D1MACH, XERMSG
C***REVISION HISTORY  (YYMMDD)
C   750101  DATE WRITTEN
C   880515  SLATEC prologue added by G. C. Nielson, NBS; parameters
C           HUGE and TINY revised to depend on D1MACH.
C   891229  Prologue description rewritten; other prologue sections
C           revised; LMATCH (location of match point for recurrences)
C           removed from argument list; argument IER changed to serve
C           only as an error flag (previously, in cases without error,
C           it returned the number of scalings); number of error codes
C           increased to provide more precise error information;
C           program comments revised; SLATEC error handler calls
C           introduced to enable printing of error messages to meet
C           SLATEC standards. These changes were done by D. W. Lozier,
C           M. A. McClain and J. M. Smith of the National Institute
C           of Standards and Technology, formerly NBS.
C   910415  Mixed type expressions eliminated; variable C1 initialized;
C           description of THRCOF expanded. These changes were done by
C           D. W. Lozier.
C***END PROLOGUE  DRC3JJ
C
      INTEGER NDIM, IER
      DOUBLE PRECISION L2, L3, M2, M3, L1MIN, L1MAX, THRCOF(NDIM)
C
      INTEGER I, INDEX, LSTEP, N, NFIN, NFINP1, NFINP2, NFINP3, NLIM,
     +        NSTEP2
      DOUBLE PRECISION A1, A1S, A2, A2S, C1, C1OLD, C2, CNORM, D1MACH,
     +                 DENOM, DV, EPS, HUGE, L1, M1, NEWFAC, OLDFAC,
     +                 ONE, RATIO, SIGN1, SIGN2, SRHUGE, SRTINY, SUM1,
     +                 SUM2, SUMBAC, SUMFOR, SUMUNI, THREE, THRESH,
     +                 TINY, TWO, X, X1, X2, X3, Y, Y1, Y2, Y3, ZERO
C
      DATA  ZERO,EPS,ONE,TWO,THREE /0.0D0,0.01D0,1.0D0,2.0D0,3.0D0/
C
C***FIRST EXECUTABLE STATEMENT  DRC3JJ
      IER=0
C  HUGE is the square root of one twentieth of the largest floating
C  point number, approximately.
      HUGE = SQRT(D1MACH(2)/20.0D0)
      SRHUGE = SQRT(HUGE)
      TINY = 1.0D0/HUGE
      SRTINY = 1.0D0/SRHUGE
C
C     LMATCH = ZERO
      M1 = - M2 - M3
C
C  Check error conditions 1 and 2.
      IF((L2-ABS(M2)+EPS.LT.ZERO).OR.
     +   (L3-ABS(M3)+EPS.LT.ZERO))THEN
         IER=1
         print*, "Exited with ier = ", IER
C          CALL XERMSG('SLATEC','DRC3JJ','L2-ABS(M2) or L3-ABS(M3) '//
C      +      'less than zero.',IER,1)
         RETURN
      ELSEIF((MOD(L2+ABS(M2)+EPS,ONE).GE.EPS+EPS).OR.
     +   (MOD(L3+ABS(M3)+EPS,ONE).GE.EPS+EPS))THEN
         IER=2
         print*, "Exited with ier = ", IER
C          CALL XERMSG('SLATEC','DRC3JJ','L2+ABS(M2) or L3+ABS(M3) '//
C      +      'not integer.',IER,1)
         RETURN
      ENDIF
C
C
C
C  Limits for L1
C
      L1MIN = MAX(ABS(L2-L3),ABS(M1))
      L1MAX = L2 + L3
C
C  Check error condition 3.
      IF(MOD(L1MAX-L1MIN+EPS,ONE).GE.EPS+EPS)THEN
         IER=3
         print*, "Exited with ier = ", IER
C         CALL XERMSG('SLATEC','DRC3JJ','L1MAX-L1MIN not integer.',IER,1)
         RETURN
      ENDIF
      IF(L1MIN.LT.L1MAX-EPS)   GO TO 20
      IF(L1MIN.LT.L1MAX+EPS)   GO TO 10
C
C  Check error condition 4.
      IER=4
      print*, "Exited with ier = ", IER
C      CALL XERMSG('SLATEC','DRC3JJ','L1MIN greater than L1MAX.',IER,1)
      RETURN
C
C  This is reached in case that L1 can take only one value,
C  i.e. L1MIN = L1MAX
C
   10 CONTINUE
C     LSCALE = 0
      THRCOF(1) = (-ONE) ** INT(ABS(L2+M2-L3+M3)+EPS) /
     1 SQRT(L1MIN + L2 + L3 + ONE)
      RETURN
C
C  This is reached in case that L1 takes more than one value,
C  i.e. L1MIN < L1MAX.
C
   20 CONTINUE
C     LSCALE = 0
      NFIN = INT(L1MAX-L1MIN+ONE+EPS)
      IF(NDIM-NFIN)  21, 23, 23
C
C  Check error condition 5.
   21 IER = 5
      print*, "Exited with ier = ", IER
C       CALL XERMSG('SLATEC','DRC3JJ','Dimension of result array for '//
C      +            '3j coefficients too small.',IER,1)
      RETURN
C
C
C  Starting forward recursion from L1MIN taking NSTEP1 steps
C
   23 L1 = L1MIN
      NEWFAC = 0.0D0
      C1 = 0.0D0
      THRCOF(1) = SRTINY
      SUM1 = (L1+L1+ONE) * TINY
C
C
      LSTEP = 1
   30 LSTEP = LSTEP + 1
      L1 = L1 + ONE
C
C
      OLDFAC = NEWFAC
      A1 = (L1+L2+L3+ONE) * (L1-L2+L3) * (L1+L2-L3) * (-L1+L2+L3+ONE)
      A2 = (L1+M1) * (L1-M1)
      NEWFAC = SQRT(A1*A2)
      IF(L1.LT.ONE+EPS)   GO TO 40
C
C
      DV = - L2*(L2+ONE) * M1 + L3*(L3+ONE) * M1 + L1*(L1-ONE) * (M3-M2)
      DENOM = (L1-ONE) * NEWFAC
C
      IF(LSTEP-2)  32, 32, 31
C
   31 C1OLD = ABS(C1)
   32 C1 = - (L1+L1-ONE) * DV / DENOM
      GO TO 50
C
C  If L1 = 1, (L1-1) has to be factored out of DV, hence
C
   40 C1 = - (L1+L1-ONE) * L1 * (M3-M2) / NEWFAC
C
   50 IF(LSTEP.GT.2)   GO TO 60
C
C
C  If L1 = L1MIN + 1, the third term in the recursion equation vanishes,
C  hence
      X = SRTINY * C1
      THRCOF(2) = X
      SUM1 = SUM1 + TINY * (L1+L1+ONE) * C1*C1
      IF(LSTEP.EQ.NFIN)   GO TO 220
      GO TO 30
C
C
   60 C2 = - L1 * OLDFAC / DENOM
C
C  Recursion to the next 3j coefficient X
C
      X = C1 * THRCOF(LSTEP-1) + C2 * THRCOF(LSTEP-2)
      THRCOF(LSTEP) = X
      SUMFOR = SUM1
      SUM1 = SUM1 + (L1+L1+ONE) * X*X
      IF(LSTEP.EQ.NFIN)   GO TO 100
C
C  See if last unnormalized 3j coefficient exceeds SRHUGE
C
      IF(ABS(X).LT.SRHUGE)   GO TO 80
C
C  This is reached if last 3j coefficient larger than SRHUGE,
C  so that the recursion series THRCOF(1), ... , THRCOF(LSTEP)
C  has to be rescaled to prevent overflow
C
C     LSCALE = LSCALE + 1
      DO 70 I=1,LSTEP
      IF(ABS(THRCOF(I)).LT.SRTINY)   THRCOF(I) = ZERO
   70 THRCOF(I) = THRCOF(I) / SRHUGE
      SUM1 = SUM1 / HUGE
      SUMFOR = SUMFOR / HUGE
      X = X / SRHUGE
C
C  As long as ABS(C1) is decreasing, the recursion proceeds towards
C  increasing 3j values and, hence, is numerically stable.  Once
C  an increase of ABS(C1) is detected, the recursion direction is
C  reversed.
C
   80 IF(C1OLD-ABS(C1))   100, 100, 30
C
C
C  Keep three 3j coefficients around LMATCH for comparison with
C  backward recursion.
C
  100 CONTINUE
C     LMATCH = L1 - 1
      X1 = X
      X2 = THRCOF(LSTEP-1)
      X3 = THRCOF(LSTEP-2)
      NSTEP2 = NFIN - LSTEP + 3
C
C
C
C
C  Starting backward recursion from L1MAX taking NSTEP2 steps, so
C  that forward and backward recursion overlap at three points
C  L1 = LMATCH+1, LMATCH, LMATCH-1.
C
      NFINP1 = NFIN + 1
      NFINP2 = NFIN + 2
      NFINP3 = NFIN + 3
      L1 = L1MAX
      THRCOF(NFIN) = SRTINY
      SUM2 = TINY * (L1+L1+ONE)
C
      L1 = L1 + TWO
      LSTEP = 1
  110 LSTEP = LSTEP + 1
      L1 = L1 - ONE
C
      OLDFAC = NEWFAC
      A1S = (L1+L2+L3)*(L1-L2+L3-ONE)*(L1+L2-L3-ONE)*(-L1+L2+L3+TWO)
      A2S = (L1+M1-ONE) * (L1-M1-ONE)
      NEWFAC = SQRT(A1S*A2S)
C
      DV = - L2*(L2+ONE) * M1 + L3*(L3+ONE) * M1 + L1*(L1-ONE) * (M3-M2)
C
      DENOM = L1 * NEWFAC
      C1 = - (L1+L1-ONE) * DV / DENOM
      IF(LSTEP.GT.2)   GO TO 120
C
C  If L1 = L1MAX + 1, the third term in the recursion formula vanishes
C
      Y = SRTINY * C1
      THRCOF(NFIN-1) = Y
      SUMBAC = SUM2
      SUM2 = SUM2 + TINY * (L1+L1-THREE) * C1*C1
C
      GO TO 110
C
C
  120 C2 = - (L1 - ONE) * OLDFAC / DENOM
C
C  Recursion to the next 3j coefficient Y
C
      Y = C1 * THRCOF(NFINP2-LSTEP) + C2 * THRCOF(NFINP3-LSTEP)
C
      IF(LSTEP.EQ.NSTEP2)   GO TO 200
C
      THRCOF(NFINP1-LSTEP) = Y
      SUMBAC = SUM2
      SUM2 = SUM2 + (L1+L1-THREE) * Y*Y
C
C  See if last unnormalized 3j coefficient exceeds SRHUGE
C
      IF(ABS(Y).LT.SRHUGE)   GO TO 110
C
C  This is reached if last 3j coefficient larger than SRHUGE,
C  so that the recursion series THRCOF(NFIN), ... ,THRCOF(NFIN-LSTEP+1)
C  has to be rescaled to prevent overflow
C
C     LSCALE = LSCALE + 1
      DO 130 I=1,LSTEP
      INDEX = NFIN - I + 1
      IF(ABS(THRCOF(INDEX)).LT.SRTINY)   THRCOF(INDEX) = ZERO
  130 THRCOF(INDEX) = THRCOF(INDEX) / SRHUGE
      SUM2 = SUM2 / HUGE
      SUMBAC = SUMBAC / HUGE
C
C
      GO TO 110
C
C
C  The forward recursion 3j coefficients X1, X2, X3 are to be matched
C  with the corresponding backward recursion values Y1, Y2, Y3.
C
  200 Y3 = Y
      Y2 = THRCOF(NFINP2-LSTEP)
      Y1 = THRCOF(NFINP3-LSTEP)
C
C
C  Determine now RATIO such that YI = RATIO * XI  (I=1,2,3) holds
C  with minimal error.
C
      RATIO = ( X1*Y1 + X2*Y2 + X3*Y3 ) / ( X1*X1 + X2*X2 + X3*X3 )
      NLIM = NFIN - NSTEP2 + 1
C
      IF(ABS(RATIO).LT.ONE)   GO TO 211
C
      DO 210 N=1,NLIM
  210 THRCOF(N) = RATIO * THRCOF(N)
      SUMUNI = RATIO * RATIO * SUMFOR + SUMBAC
      GO TO 230
C
  211 NLIM = NLIM + 1
      RATIO = ONE / RATIO
      DO 212 N=NLIM,NFIN
  212 THRCOF(N) = RATIO * THRCOF(N)
      SUMUNI = SUMFOR + RATIO*RATIO*SUMBAC
      GO TO 230
C
  220 SUMUNI = SUM1
C
C
C  Normalize 3j coefficients
C
  230 CNORM = ONE / SQRT(SUMUNI)
C
C  Sign convention for last 3j coefficient determines overall phase
C
      SIGN1 = SIGN(ONE,THRCOF(NFIN))
      SIGN2 = (-ONE) ** INT(ABS(L2+M2-L3+M3)+EPS)
      IF(SIGN1*SIGN2) 235,235,236
  235 CNORM = - CNORM
C
  236 IF(ABS(CNORM).LT.ONE)   GO TO 250
C
      DO 240 N=1,NFIN
  240 THRCOF(N) = CNORM * THRCOF(N)
      RETURN
C
  250 THRESH = TINY / ABS(CNORM)
      DO 251 N=1,NFIN
      IF(ABS(THRCOF(N)).LT.THRESH)   THRCOF(N) = ZERO
  251 THRCOF(N) = CNORM * THRCOF(N)
C
      RETURN
      END


*DECK DRC3JM
      SUBROUTINE DRC3JM (L1, L2, L3, M1, M2MIN, M2MAX, THRCOF, NDIM,
     +   IER)
C***BEGIN PROLOGUE  DRC3JM
C***PURPOSE  Evaluate the 3j symbol g(M2) = (L1 L2   L3  )
C                                           (M1 M2 -M1-M2)
C            for all allowed values of M2, the other parameters
C            being held fixed.
C***LIBRARY   SLATEC
C***CATEGORY  C19
C***TYPE      DOUBLE PRECISION (RC3JM-S, DRC3JM-D)
C***KEYWORDS  3J COEFFICIENTS, 3J SYMBOLS, CLEBSCH-GORDAN COEFFICIENTS,
C             RACAH COEFFICIENTS, VECTOR ADDITION COEFFICIENTS,
C             WIGNER COEFFICIENTS
C***AUTHOR  Gordon, R. G., Harvard University
C           Schulten, K., Max Planck Institute
C***DESCRIPTION
C
C *Usage:
C
C        DOUBLE PRECISION L1, L2, L3, M1, M2MIN, M2MAX, THRCOF(NDIM)
C        INTEGER NDIM, IER
C
C        CALL DRC3JM (L1, L2, L3, M1, M2MIN, M2MAX, THRCOF, NDIM, IER)
C
C *Arguments:
C
C     L1 :IN      Parameter in 3j symbol.
C
C     L2 :IN      Parameter in 3j symbol.
C
C     L3 :IN      Parameter in 3j symbol.
C
C     M1 :IN      Parameter in 3j symbol.
C
C     M2MIN :OUT  Smallest allowable M2 in 3j symbol.
C
C     M2MAX :OUT  Largest allowable M2 in 3j symbol.
C
C     THRCOF :OUT Set of 3j coefficients generated by evaluating the
C                 3j symbol for all allowed values of M2.  THRCOF(I)
C                 will contain g(M2MIN+I-1), I=1,2,...,M2MAX-M2MIN+1.
C
C     NDIM :IN    Declared length of THRCOF in calling program.
C
C     IER :OUT    Error flag.
C                 IER=0 No errors.
C                 IER=1 Either L1.LT.ABS(M1) or L1+ABS(M1) non-integer.
C                 IER=2 ABS(L1-L2).LE.L3.LE.L1+L2 not satisfied.
C                 IER=3 L1+L2+L3 not an integer.
C                 IER=4 M2MAX-M2MIN not an integer.
C                 IER=5 M2MAX less than M2MIN.
C                 IER=6 NDIM less than M2MAX-M2MIN+1.
C
C *Description:
C
C     Although conventionally the parameters of the vector addition
C  coefficients satisfy certain restrictions, such as being integers
C  or integers plus 1/2, the restrictions imposed on input to this
C  subroutin are somewhat weaker. See, for example, Section 27.9 of
C  Abramowitz and Stegun or Appendix C of Volume II of A. Messiah.
C  The restrictions imposed by this subroutine are
C       1. L1.GE.ABS(M1) and L1+ABS(M1) must be an integer;
C       2. ABS(L1-L2).LE.L3.LE.L1+L2;
C       3. L1+L2+L3 must be an integer;
C       4. M2MAX-M2MIN must be an integer, where
C          M2MAX=MIN(L2,L3-M1) and M2MIN=MAX(-L2,-L3-M1).
C  If the conventional restrictions are satisfied, then these
C  restrictions are met.
C
C     The user should be cautious in using input parameters that do
C  not satisfy the conventional restrictions. For example, the
C  the subroutine produces values of
C       g(M2) = (0.75 1.50   1.75  )
C               (0.25  M2  -0.25-M2)
C  for M2=-1.5,-0.5,0.5,1.5 but none of the symmetry properties of the
C  3j symbol, set forth on page 1056 of Messiah, is satisfied.
C
C     The subroutine generates g(M2MIN), g(M2MIN+1), ..., g(M2MAX)
C  where M2MIN and M2MAX are defined above. The sequence g(M2) is
C  generated by a three-term recurrence algorithm with scaling to
C  control overflow. Both backward and forward recurrence are used to
C  maintain numerical stability. The two recurrence sequences are
C  matched at an interior point and are normalized from the unitary
C  property of 3j coefficients and Wigner's phase convention.
C
C    The algorithm is suited to applications in which large quantum
C  numbers arise, such as in molecular dynamics.
C
C***REFERENCES  1. Abramowitz, M., and Stegun, I. A., Eds., Handbook
C                  of Mathematical Functions with Formulas, Graphs
C                  and Mathematical Tables, NBS Applied Mathematics
C                  Series 55, June 1964 and subsequent printings.
C               2. Messiah, Albert., Quantum Mechanics, Volume II,
C                  North-Holland Publishing Company, 1963.
C               3. Schulten, Klaus and Gordon, Roy G., Exact recursive
C                  evaluation of 3j and 6j coefficients for quantum-
C                  mechanical coupling of angular momenta, J Math
C                  Phys, v 16, no. 10, October 1975, pp. 1961-1970.
C               4. Schulten, Klaus and Gordon, Roy G., Semiclassical
C                  approximations to 3j and 6j coefficients for
C                  quantum-mechanical coupling of angular momenta,
C                  J Math Phys, v 16, no. 10, October 1975,
C                  pp. 1971-1988.
C               5. Schulten, Klaus and Gordon, Roy G., Recursive
C                  evaluation of 3j and 6j coefficients, Computer
C                  Phys Comm, v 11, 1976, pp. 269-278.
C***ROUTINES CALLED  D1MACH, XERMSG
C***REVISION HISTORY  (YYMMDD)
C   750101  DATE WRITTEN
C   880515  SLATEC prologue added by G. C. Nielson, NBS; parameters
C           HUGE and TINY revised to depend on D1MACH.
C   891229  Prologue description rewritten; other prologue sections
C           revised; MMATCH (location of match point for recurrences)
C           removed from argument list; argument IER changed to serve
C           only as an error flag (previously, in cases without error,
C           it returned the number of scalings); number of error codes
C           increased to provide more precise error information;
C           program comments revised; SLATEC error handler calls
C           introduced to enable printing of error messages to meet
C           SLATEC standards. These changes were done by D. W. Lozier,
C           M. A. McClain and J. M. Smith of the National Institute
C           of Standards and Technology, formerly NBS.
C   910415  Mixed type expressions eliminated; variable C1 initialized;
C           description of THRCOF expanded. These changes were done by
C           D. W. Lozier.
C***END PROLOGUE  DRC3JM
C
      INTEGER NDIM, IER
      DOUBLE PRECISION L1, L2, L3, M1, M2MIN, M2MAX, THRCOF(NDIM)
C
      INTEGER I, INDEX, LSTEP, N, NFIN, NFINP1, NFINP2, NFINP3, NLIM,
     +        NSTEP2
      DOUBLE PRECISION A1, A1S, C1, C1OLD, C2, CNORM, D1MACH, DV, EPS,
     +                 HUGE, M2, M3, NEWFAC, OLDFAC, ONE, RATIO, SIGN1,
     +                 SIGN2, SRHUGE, SRTINY, SUM1, SUM2, SUMBAC,
     +                 SUMFOR, SUMUNI, THRESH, TINY, TWO, X, X1, X2, X3,
     +                 Y, Y1, Y2, Y3, ZERO
C
      DATA  ZERO,EPS,ONE,TWO /0.0D0,0.01D0,1.0D0,2.0D0/
C
C***FIRST EXECUTABLE STATEMENT  DRC3JM
C  Debug
C       print*, "PARAMETERS FOR FUNCTION DRC3JM"
C       print*, "L1", L1
C       print*, "L2", L2
C       print*, "L3", L3  
C       print*, "M1", M1
C       print*, "NDIM", NDIM


      IER=0
C  HUGE is the square root of one twentieth of the largest floating
C  point number, approximately.
C
C
C =============
C = Important =
C =============
C The function D1MACH 
      HUGE = SQRT(D1MACH(2)/20.0D0)
C       HUGE = SQRT(1.0D308/20.0D0)
      SRHUGE = SQRT(HUGE)
      TINY = 1.0D0/HUGE
      SRTINY = 1.0D0/SRHUGE
C
C     MMATCH = ZERO
C
C
C  Check error conditions 1, 2, and 3.
      IF((L1-ABS(M1)+EPS.LT.ZERO).OR.
     +   (MOD(L1+ABS(M1)+EPS,ONE).GE.EPS+EPS))THEN
         IER=1
		 print*, "Exited with ier = ", IER
C          CALL XERMSG('SLATEC','DRC3JM','L1-ABS(M1) less than zero or '//
C      +      'L1+ABS(M1) not integer.',IER,1)
         RETURN
      ELSEIF((L1+L2-L3.LT.-EPS).OR.(L1-L2+L3.LT.-EPS).OR.
     +   (-L1+L2+L3.LT.-EPS))THEN
         IER=2
		 print*, "Exited with ier = ", IER
C          CALL XERMSG('SLATEC','DRC3JM','L1, L2, L3 do not satisfy '//
C      +      'triangular condition.',IER,1)
         RETURN
      ELSEIF(MOD(L1+L2+L3+EPS,ONE).GE.EPS+EPS)THEN
         IER=3
		 print*, "Exited with ier = ", IER
C          CALL XERMSG('SLATEC','DRC3JM','L1+L2+L3 not integer.',IER,1)
C          RETURN
      ENDIF
C
C
C  Limits for M2
      M2MIN = MAX(-L2,-L3-M1)
      M2MAX = MIN(L2,L3-M1)
C  Debug
C       print *, "M2MIN = ", M2MIN
C       print *, "M2MAX = ", M2MAX      
C
C  Check error condition 4.
      IF(MOD(M2MAX-M2MIN+EPS,ONE).GE.EPS+EPS)THEN
         IER=4
		 print*, "Exited with ier = ", IER
C          CALL XERMSG('SLATEC','DRC3JM','M2MAX-M2MIN not integer.',IER,1)
C          RETURN
      ENDIF
      IF(M2MIN.LT.M2MAX-EPS)   GO TO 20
      IF(M2MIN.LT.M2MAX+EPS)   GO TO 10
C
C  Check error condition 5.
      IER=5
	  print*, "Exited with ier = ", IER
C      CALL XERMSG('SLATEC','DRC3JM','M2MIN greater than M2MAX.',IER,1)
      RETURN
C
C
C  This is reached in case that M2 and M3 can take only one value.
   10 CONTINUE
C     MSCALE = 0
      THRCOF(1) = (-ONE) ** INT(ABS(L2-L3-M1)+EPS) /
     1 SQRT(L1+L2+L3+ONE)
      RETURN
C
C  This is reached in case that M1 and M2 take more than one value.
   20 CONTINUE
C     MSCALE = 0
      NFIN = INT(M2MAX-M2MIN+ONE+EPS)
      IF(NDIM-NFIN)   21, 23, 23
C
C  Check error condition 6.
   21 IER = 6
	  print*, "Exited with ier = ", IER
C       CALL XERMSG('SLATEC','DRC3JM','Dimension of result array for '//
C      +            '3j coefficients too small.',IER,1)
      RETURN
C
C
C
C  Start of forward recursion from M2 = M2MIN
C
   23 M2 = M2MIN
      THRCOF(1) = SRTINY
      NEWFAC = 0.0D0
      C1 = 0.0D0
      SUM1 = TINY
C
C
      LSTEP = 1
   30 LSTEP = LSTEP + 1
      M2 = M2 + ONE
      M3 = - M1 - M2
C
C
      OLDFAC = NEWFAC
      A1 = (L2-M2+ONE) * (L2+M2) * (L3+M3+ONE) * (L3-M3)
      NEWFAC = SQRT(A1)
C
C
      DV = (L1+L2+L3+ONE)*(L2+L3-L1) - (L2-M2+ONE)*(L3+M3+ONE)
     1                               - (L2+M2-ONE)*(L3-M3-ONE)
C
      IF(LSTEP-2)  32, 32, 31
C
   31 C1OLD = ABS(C1)
   32 C1 = - DV / NEWFAC
C
      IF(LSTEP.GT.2)   GO TO 60
C
C
C  If M2 = M2MIN + 1, the third term in the recursion equation vanishes,
C  hence
C
      X = SRTINY * C1
      THRCOF(2) = X
      SUM1 = SUM1 + TINY * C1*C1
      IF(LSTEP.EQ.NFIN)   GO TO 220
      GO TO 30
C
C
   60 C2 = - OLDFAC / NEWFAC
C
C  Recursion to the next 3j coefficient
      X = C1 * THRCOF(LSTEP-1) + C2 * THRCOF(LSTEP-2)
      THRCOF(LSTEP) = X
      SUMFOR = SUM1
      SUM1 = SUM1 + X*X
      IF(LSTEP.EQ.NFIN)   GO TO 100
C
C  See if last unnormalized 3j coefficient exceeds SRHUGE
C
      IF(ABS(X).LT.SRHUGE)   GO TO 80
C
C  This is reached if last 3j coefficient larger than SRHUGE,
C  so that the recursion series THRCOF(1), ... , THRCOF(LSTEP)
C  has to be rescaled to prevent overflow
C
C     MSCALE = MSCALE + 1
      DO 70 I=1,LSTEP
      IF(ABS(THRCOF(I)).LT.SRTINY)   THRCOF(I) = ZERO
   70 THRCOF(I) = THRCOF(I) / SRHUGE
      SUM1 = SUM1 / HUGE
      SUMFOR = SUMFOR / HUGE
      X = X / SRHUGE
C
C
C  As long as ABS(C1) is decreasing, the recursion proceeds towards
C  increasing 3j values and, hence, is numerically stable.  Once
C  an increase of ABS(C1) is detected, the recursion direction is
C  reversed.
C
   80 IF(C1OLD-ABS(C1))   100, 100, 30
C
C
C  Keep three 3j coefficients around MMATCH for comparison later
C  with backward recursion values.
C
  100 CONTINUE
C     MMATCH = M2 - 1
      NSTEP2 = NFIN - LSTEP + 3
      X1 = X
      X2 = THRCOF(LSTEP-1)
      X3 = THRCOF(LSTEP-2)
C
C  Starting backward recursion from M2MAX taking NSTEP2 steps, so
C  that forwards and backwards recursion overlap at the three points
C  M2 = MMATCH+1, MMATCH, MMATCH-1.
C
      NFINP1 = NFIN + 1
      NFINP2 = NFIN + 2
      NFINP3 = NFIN + 3
      THRCOF(NFIN) = SRTINY
      SUM2 = TINY
C
C
C
      M2 = M2MAX + TWO
      LSTEP = 1
  110 LSTEP = LSTEP + 1
      M2 = M2 - ONE
      M3 = - M1 - M2
      OLDFAC = NEWFAC
      A1S = (L2-M2+TWO) * (L2+M2-ONE) * (L3+M3+TWO) * (L3-M3-ONE)
      NEWFAC = SQRT(A1S)
      DV = (L1+L2+L3+ONE)*(L2+L3-L1) - (L2-M2+ONE)*(L3+M3+ONE)
     1                               - (L2+M2-ONE)*(L3-M3-ONE)
      C1 = - DV / NEWFAC
      IF(LSTEP.GT.2)   GO TO 120
C
C  If M2 = M2MAX + 1 the third term in the recursion equation vanishes
C
      Y = SRTINY * C1
      THRCOF(NFIN-1) = Y
      IF(LSTEP.EQ.NSTEP2)   GO TO 200
      SUMBAC = SUM2
      SUM2 = SUM2 + Y*Y
      GO TO 110
C
  120 C2 = - OLDFAC / NEWFAC
C
C  Recursion to the next 3j coefficient
C
      Y = C1 * THRCOF(NFINP2-LSTEP) + C2 * THRCOF(NFINP3-LSTEP)
C
      IF(LSTEP.EQ.NSTEP2)   GO TO 200
C
      THRCOF(NFINP1-LSTEP) = Y
      SUMBAC = SUM2
      SUM2 = SUM2 + Y*Y
C
C
C  See if last 3j coefficient exceeds SRHUGE
C
      IF(ABS(Y).LT.SRHUGE)   GO TO 110
C
C  This is reached if last 3j coefficient larger than SRHUGE,
C  so that the recursion series THRCOF(NFIN), ... , THRCOF(NFIN-LSTEP+1)
C  has to be rescaled to prevent overflow.
C
C     MSCALE = MSCALE + 1
      DO 111 I=1,LSTEP
      INDEX = NFIN - I + 1
      IF(ABS(THRCOF(INDEX)).LT.SRTINY)
     1  THRCOF(INDEX) = ZERO
  111 THRCOF(INDEX) = THRCOF(INDEX) / SRHUGE
      SUM2 = SUM2 / HUGE
      SUMBAC = SUMBAC / HUGE
C
      GO TO 110
C
C
C
C  The forward recursion 3j coefficients X1, X2, X3 are to be matched
C  with the corresponding backward recursion values Y1, Y2, Y3.
C
  200 Y3 = Y
      Y2 = THRCOF(NFINP2-LSTEP)
      Y1 = THRCOF(NFINP3-LSTEP)
C
C
C  Determine now RATIO such that YI = RATIO * XI  (I=1,2,3) holds
C  with minimal error.
C
      RATIO = ( X1*Y1 + X2*Y2 + X3*Y3 ) / ( X1*X1 + X2*X2 + X3*X3 )
      NLIM = NFIN - NSTEP2 + 1
C
      IF(ABS(RATIO).LT.ONE)   GO TO 211
C
      DO 210 N=1,NLIM
  210 THRCOF(N) = RATIO * THRCOF(N)
      SUMUNI = RATIO * RATIO * SUMFOR + SUMBAC
      GO TO 230
C
  211 NLIM = NLIM + 1
      RATIO = ONE / RATIO
      DO 212 N=NLIM,NFIN
  212 THRCOF(N) = RATIO * THRCOF(N)
      SUMUNI = SUMFOR + RATIO*RATIO*SUMBAC
      GO TO 230
C
  220 SUMUNI = SUM1
C
C
C  Normalize 3j coefficients
C
  230 CNORM = ONE / SQRT((L1+L1+ONE) * SUMUNI)
C
C  Sign convention for last 3j coefficient determines overall phase
C
      SIGN1 = SIGN(ONE,THRCOF(NFIN))
      SIGN2 = (-ONE) ** INT(ABS(L2-L3-M1)+EPS)
      IF(SIGN1*SIGN2)  235,235,236
  235 CNORM = - CNORM
C
  236 IF(ABS(CNORM).LT.ONE)   GO TO 250
C
      DO 240 N=1,NFIN
  240 THRCOF(N) = CNORM * THRCOF(N)
      RETURN
C
  250 THRESH = TINY / ABS(CNORM)
      DO 251 N=1,NFIN
      IF(ABS(THRCOF(N)).LT.THRESH)   THRCOF(N) = ZERO
  251 THRCOF(N) = CNORM * THRCOF(N)
C
C
C
      RETURN
      END



*DECK DRC6J
      SUBROUTINE DRC6J (L2, L3, L4, L5, L6, L1MIN, L1MAX, SIXCOF, NDIM,
     +   IER)
C***BEGIN PROLOGUE  DRC6J
C***PURPOSE  Evaluate the 6j symbol h(L1) = {L1 L2 L3}
C                                           {L4 L5 L6}
C            for all allowed values of L1, the other parameters
C            being held fixed.
C***LIBRARY   SLATEC
C***CATEGORY  C19
C***TYPE      DOUBLE PRECISION (RC6J-S, DRC6J-D)
C***KEYWORDS  6J COEFFICIENTS, 6J SYMBOLS, CLEBSCH-GORDAN COEFFICIENTS,
C             RACAH COEFFICIENTS, VECTOR ADDITION COEFFICIENTS,
C             WIGNER COEFFICIENTS
C***AUTHOR  Gordon, R. G., Harvard University
C           Schulten, K., Max Planck Institute
C***DESCRIPTION
C
C *Usage:
C
C        DOUBLE PRECISION L2, L3, L4, L5, L6, L1MIN, L1MAX, SIXCOF(NDIM)
C        INTEGER NDIM, IER
C
C        CALL DRC6J(L2, L3, L4, L5, L6, L1MIN, L1MAX, SIXCOF, NDIM, IER)
C
C *Arguments:
C
C     L2 :IN      Parameter in 6j symbol.
C
C     L3 :IN      Parameter in 6j symbol.
C
C     L4 :IN      Parameter in 6j symbol.
C
C     L5 :IN      Parameter in 6j symbol.
C
C     L6 :IN      Parameter in 6j symbol.
C
C     L1MIN :OUT  Smallest allowable L1 in 6j symbol.
C
C     L1MAX :OUT  Largest allowable L1 in 6j symbol.
C
C     SIXCOF :OUT Set of 6j coefficients generated by evaluating the
C                 6j symbol for all allowed values of L1.  SIXCOF(I)
C                 will contain h(L1MIN+I-1), I=1,2,...,L1MAX-L1MIN+1.
C
C     NDIM :IN    Declared length of SIXCOF in calling program.
C
C     IER :OUT    Error flag.
C                 IER=0 No errors.
C                 IER=1 L2+L3+L5+L6 or L4+L2+L6 not an integer.
C                 IER=2 L4, L2, L6 triangular condition not satisfied.
C                 IER=3 L4, L5, L3 triangular condition not satisfied.
C                 IER=4 L1MAX-L1MIN not an integer.
C                 IER=5 L1MAX less than L1MIN.
C                 IER=6 NDIM less than L1MAX-L1MIN+1.
C
C *Description:
C
C     The definition and properties of 6j symbols can be found, for
C  example, in Appendix C of Volume II of A. Messiah. Although the
C  parameters of the vector addition coefficients satisfy certain
C  conventional restrictions, the restriction that they be non-negative
C  integers or non-negative integers plus 1/2 is not imposed on input
C  to this subroutine. The restrictions imposed are
C       1. L2+L3+L5+L6 and L2+L4+L6 must be integers;
C       2. ABS(L2-L4).LE.L6.LE.L2+L4 must be satisfied;
C       3. ABS(L4-L5).LE.L3.LE.L4+L5 must be satisfied;
C       4. L1MAX-L1MIN must be a non-negative integer, where
C          L1MAX=MIN(L2+L3,L5+L6) and L1MIN=MAX(ABS(L2-L3),ABS(L5-L6)).
C  If all the conventional restrictions are satisfied, then these
C  restrictions are met. Conversely, if input to this subroutine meets
C  all of these restrictions and the conventional restriction stated
C  above, then all the conventional restrictions are satisfied.
C
C     The user should be cautious in using input parameters that do
C  not satisfy the conventional restrictions. For example, the
C  the subroutine produces values of
C       h(L1) = { L1 2/3  1 }
C               {2/3 2/3 2/3}
C  for L1=1/3 and 4/3 but none of the symmetry properties of the 6j
C  symbol, set forth on pages 1063 and 1064 of Messiah, is satisfied.
C
C     The subroutine generates h(L1MIN), h(L1MIN+1), ..., h(L1MAX)
C  where L1MIN and L1MAX are defined above. The sequence h(L1) is
C  generated by a three-term recurrence algorithm with scaling to
C  control overflow. Both backward and forward recurrence are used to
C  maintain numerical stability. The two recurrence sequences are
C  matched at an interior point and are normalized from the unitary
C  property of 6j coefficients and Wigner's phase convention.
C
C    The algorithm is suited to applications in which large quantum
C  numbers arise, such as in molecular dynamics.
C
C***REFERENCES  1. Messiah, Albert., Quantum Mechanics, Volume II,
C                  North-Holland Publishing Company, 1963.
C               2. Schulten, Klaus and Gordon, Roy G., Exact recursive
C                  evaluation of 3j and 6j coefficients for quantum-
C                  mechanical coupling of angular momenta, J Math
C                  Phys, v 16, no. 10, October 1975, pp. 1961-1970.
C               3. Schulten, Klaus and Gordon, Roy G., Semiclassical
C                  approximations to 3j and 6j coefficients for
C                  quantum-mechanical coupling of angular momenta,
C                  J Math Phys, v 16, no. 10, October 1975,
C                  pp. 1971-1988.
C               4. Schulten, Klaus and Gordon, Roy G., Recursive
C                  evaluation of 3j and 6j coefficients, Computer
C                  Phys Comm, v 11, 1976, pp. 269-278.
C***ROUTINES CALLED  D1MACH, XERMSG
C***REVISION HISTORY  (YYMMDD)
C   750101  DATE WRITTEN
C   880515  SLATEC prologue added by G. C. Nielson, NBS; parameters
C           HUGE and TINY revised to depend on D1MACH.
C   891229  Prologue description rewritten; other prologue sections
C           revised; LMATCH (location of match point for recurrences)
C           removed from argument list; argument IER changed to serve
C           only as an error flag (previously, in cases without error,
C           it returned the number of scalings); number of error codes
C           increased to provide more precise error information;
C           program comments revised; SLATEC error handler calls
C           introduced to enable printing of error messages to meet
C           SLATEC standards. These changes were done by D. W. Lozier,
C           M. A. McClain and J. M. Smith of the National Institute
C           of Standards and Technology, formerly NBS.
C   910415  Mixed type expressions eliminated; variable C1 initialized;
C           description of SIXCOF expanded. These changes were done by
C           D. W. Lozier.
C***END PROLOGUE  DRC6J
C
      INTEGER NDIM, IER
      DOUBLE PRECISION L2, L3, L4, L5, L6, L1MIN, L1MAX, SIXCOF(NDIM)
C
      INTEGER I, INDEX, LSTEP, N, NFIN, NFINP1, NFINP2, NFINP3, NLIM,
     +        NSTEP2
      DOUBLE PRECISION A1, A1S, A2, A2S, C1, C1OLD, C2, CNORM, D1MACH,
     +                 DENOM, DV, EPS, HUGE, L1, NEWFAC, OLDFAC, ONE,
     +                 RATIO, SIGN1, SIGN2, SRHUGE, SRTINY, SUM1, SUM2,
     +                 SUMBAC, SUMFOR, SUMUNI, THREE, THRESH, TINY, TWO,
     +                 X, X1, X2, X3, Y, Y1, Y2, Y3, ZERO
C
      DATA  ZERO,EPS,ONE,TWO,THREE /0.0D0,0.01D0,1.0D0,2.0D0,3.0D0/
C
C***FIRST EXECUTABLE STATEMENT  DRC6J
      IER=0
C  HUGE is the square root of one twentieth of the largest floating
C  point number, approximately.
      HUGE = SQRT(D1MACH(2)/20.0D0)
      SRHUGE = SQRT(HUGE)
      TINY = 1.0D0/HUGE
      SRTINY = 1.0D0/SRHUGE
C
C     LMATCH = ZERO
C
C  Check error conditions 1, 2, and 3.
      IF((MOD(L2+L3+L5+L6+EPS,ONE).GE.EPS+EPS).OR.
     +   (MOD(L4+L2+L6+EPS,ONE).GE.EPS+EPS))THEN
         IER=1
         print*, "Exited with ier = ", IER
C          CALL XERMSG('SLATEC','DRC6J','L2+L3+L5+L6 or L4+L2+L6 not '//
C      +      'integer.',IER,1)
         RETURN
      ELSEIF((L4+L2-L6.LT.ZERO).OR.(L4-L2+L6.LT.ZERO).OR.
     +   (-L4+L2+L6.LT.ZERO))THEN
         IER=2
         print*, "Exited with ier = ", IER
C          CALL XERMSG('SLATEC','DRC6J','L4, L2, L6 triangular '//
C      +      'condition not satisfied.',IER,1)
         RETURN
      ELSEIF((L4-L5+L3.LT.ZERO).OR.(L4+L5-L3.LT.ZERO).OR.
     +   (-L4+L5+L3.LT.ZERO))THEN
         IER=3
         print*, "Exited with ier = ", IER
C          CALL XERMSG('SLATEC','DRC6J','L4, L5, L3 triangular '//
C      +      'condition not satisfied.',IER,1)
         RETURN
      ENDIF
C
C  Limits for L1
C
      L1MIN = MAX(ABS(L2-L3),ABS(L5-L6))
      L1MAX = MIN(L2+L3,L5+L6)
C
C  Check error condition 4.
      IF(MOD(L1MAX-L1MIN+EPS,ONE).GE.EPS+EPS)THEN
         IER=4
         print*, "Exited with ier = ", IER
C         CALL XERMSG('SLATEC','DRC6J','L1MAX-L1MIN not integer.',IER,1)
         RETURN
      ENDIF
      IF(L1MIN.LT.L1MAX-EPS)   GO TO 20
      IF(L1MIN.LT.L1MAX+EPS)   GO TO 10
C
C  Check error condition 5.
      IER=5
      print*, "Exited with ier = ", IER
C      CALL XERMSG('SLATEC','DRC6J','L1MIN greater than L1MAX.',IER,1)
      RETURN
C
C
C  This is reached in case that L1 can take only one value
C
   10 CONTINUE
C     LSCALE = 0
      SIXCOF(1) = (-ONE) ** INT(L2+L3+L5+L6+EPS) /
     1            SQRT((L1MIN+L1MIN+ONE)*(L4+L4+ONE))
      RETURN
C
C
C  This is reached in case that L1 can take more than one value.
C
   20 CONTINUE
C     LSCALE = 0
      NFIN = INT(L1MAX-L1MIN+ONE+EPS)
      IF(NDIM-NFIN)   21, 23, 23
C
C  Check error condition 6.
   21 IER = 6
      print*, "Exited with ier = ", IER
C       CALL XERMSG('SLATEC','DRC6J','Dimension of result array for 6j '//
C      +            'coefficients too small.',IER,1)
      RETURN
C
C
C  Start of forward recursion
C
   23 L1 = L1MIN
      NEWFAC = 0.0D0
      C1 = 0.0D0
      SIXCOF(1) = SRTINY
      SUM1 = (L1+L1+ONE) * TINY
C
      LSTEP = 1
   30 LSTEP = LSTEP + 1
      L1 = L1 + ONE
C
      OLDFAC = NEWFAC
      A1 = (L1+L2+L3+ONE) * (L1-L2+L3) * (L1+L2-L3) * (-L1+L2+L3+ONE)
      A2 = (L1+L5+L6+ONE) * (L1-L5+L6) * (L1+L5-L6) * (-L1+L5+L6+ONE)
      NEWFAC = SQRT(A1*A2)
C
      IF(L1.LT.ONE+EPS)   GO TO 40
C
      DV = TWO * ( L2*(L2+ONE)*L5*(L5+ONE) + L3*(L3+ONE)*L6*(L6+ONE)
     1           - L1*(L1-ONE)*L4*(L4+ONE) )
     2                   - (L2*(L2+ONE) + L3*(L3+ONE) - L1*(L1-ONE))
     3                   * (L5*(L5+ONE) + L6*(L6+ONE) - L1*(L1-ONE))
C
      DENOM = (L1-ONE) * NEWFAC
C
      IF(LSTEP-2)  32, 32, 31
C
   31 C1OLD = ABS(C1)
   32 C1 = - (L1+L1-ONE) * DV / DENOM
      GO TO 50
C
C  If L1 = 1, (L1 - 1) has to be factored out of DV, hence
C
   40 C1 = - TWO * ( L2*(L2+ONE) + L5*(L5+ONE) - L4*(L4+ONE) )
     1 / NEWFAC
C
   50 IF(LSTEP.GT.2)   GO TO 60
C
C  If L1 = L1MIN + 1, the third term in recursion equation vanishes
C
      X = SRTINY * C1
      SIXCOF(2) = X
      SUM1 = SUM1 + TINY * (L1+L1+ONE) * C1 * C1
C
      IF(LSTEP.EQ.NFIN)   GO TO 220
      GO TO 30
C
C
   60 C2 = - L1 * OLDFAC / DENOM
C
C  Recursion to the next 6j coefficient X
C
      X = C1 * SIXCOF(LSTEP-1) + C2 * SIXCOF(LSTEP-2)
      SIXCOF(LSTEP) = X
C
      SUMFOR = SUM1
      SUM1 = SUM1 + (L1+L1+ONE) * X * X
      IF(LSTEP.EQ.NFIN)   GO TO 100
C
C  See if last unnormalized 6j coefficient exceeds SRHUGE
C
      IF(ABS(X).LT.SRHUGE)   GO TO 80
C
C  This is reached if last 6j coefficient larger than SRHUGE,
C  so that the recursion series SIXCOF(1), ... ,SIXCOF(LSTEP)
C  has to be rescaled to prevent overflow
C
C     LSCALE = LSCALE + 1
      DO 70 I=1,LSTEP
      IF(ABS(SIXCOF(I)).LT.SRTINY)   SIXCOF(I) = ZERO
   70 SIXCOF(I) = SIXCOF(I) / SRHUGE
      SUM1 = SUM1 / HUGE
      SUMFOR = SUMFOR / HUGE
      X = X / SRHUGE
C
C
C  As long as the coefficient ABS(C1) is decreasing, the recursion
C  proceeds towards increasing 6j values and, hence, is numerically
C  stable.  Once an increase of ABS(C1) is detected, the recursion
C  direction is reversed.
C
   80 IF(C1OLD-ABS(C1))   100, 100, 30
C
C
C  Keep three 6j coefficients around LMATCH for comparison later
C  with backward recursion.
C
  100 CONTINUE
C     LMATCH = L1 - 1
      X1 = X
      X2 = SIXCOF(LSTEP-1)
      X3 = SIXCOF(LSTEP-2)
C
C
C
C  Starting backward recursion from L1MAX taking NSTEP2 steps, so
C  that forward and backward recursion overlap at the three points
C  L1 = LMATCH+1, LMATCH, LMATCH-1.
C
      NFINP1 = NFIN + 1
      NFINP2 = NFIN + 2
      NFINP3 = NFIN + 3
      NSTEP2 = NFIN - LSTEP + 3
      L1 = L1MAX
C
      SIXCOF(NFIN) = SRTINY
      SUM2 = (L1+L1+ONE) * TINY
C
C
      L1 = L1 + TWO
      LSTEP = 1
  110 LSTEP = LSTEP + 1
      L1 = L1 - ONE
C
      OLDFAC = NEWFAC
      A1S = (L1+L2+L3)*(L1-L2+L3-ONE)*(L1+L2-L3-ONE)*(-L1+L2+L3+TWO)
      A2S = (L1+L5+L6)*(L1-L5+L6-ONE)*(L1+L5-L6-ONE)*(-L1+L5+L6+TWO)
      NEWFAC = SQRT(A1S*A2S)
C
      DV = TWO * ( L2*(L2+ONE)*L5*(L5+ONE) + L3*(L3+ONE)*L6*(L6+ONE)
     1           - L1*(L1-ONE)*L4*(L4+ONE) )
     2                   - (L2*(L2+ONE) + L3*(L3+ONE) - L1*(L1-ONE))
     3                   * (L5*(L5+ONE) + L6*(L6+ONE) - L1*(L1-ONE))
C
      DENOM = L1 * NEWFAC
      C1 = - (L1+L1-ONE) * DV / DENOM
      IF(LSTEP.GT.2)   GO TO 120
C
C  If L1 = L1MAX + 1 the third term in the recursion equation vanishes
C
      Y = SRTINY * C1
      SIXCOF(NFIN-1) = Y
      IF(LSTEP.EQ.NSTEP2)   GO TO 200
      SUMBAC = SUM2
      SUM2 = SUM2 + (L1+L1-THREE) * C1 * C1 * TINY
      GO TO 110
C
C
  120 C2 = - (L1-ONE) * OLDFAC / DENOM
C
C  Recursion to the next 6j coefficient Y
C
      Y = C1 * SIXCOF(NFINP2-LSTEP) + C2 * SIXCOF(NFINP3-LSTEP)
      IF(LSTEP.EQ.NSTEP2)   GO TO 200
      SIXCOF(NFINP1-LSTEP) = Y
      SUMBAC = SUM2
      SUM2 = SUM2 + (L1+L1-THREE) * Y * Y
C
C  See if last unnormalized 6j coefficient exceeds SRHUGE
C
      IF(ABS(Y).LT.SRHUGE)   GO TO 110
C
C  This is reached if last 6j coefficient larger than SRHUGE,
C  so that the recursion series SIXCOF(NFIN), ... ,SIXCOF(NFIN-LSTEP+1)
C  has to be rescaled to prevent overflow
C
C     LSCALE = LSCALE + 1
      DO 130 I=1,LSTEP
      INDEX = NFIN-I+1
      IF(ABS(SIXCOF(INDEX)).LT.SRTINY)   SIXCOF(INDEX) = ZERO
  130 SIXCOF(INDEX) = SIXCOF(INDEX) / SRHUGE
      SUMBAC = SUMBAC / HUGE
      SUM2 = SUM2 / HUGE
C
      GO TO 110
C
C
C  The forward recursion 6j coefficients X1, X2, X3 are to be matched
C  with the corresponding backward recursion values Y1, Y2, Y3.
C
  200 Y3 = Y
      Y2 = SIXCOF(NFINP2-LSTEP)
      Y1 = SIXCOF(NFINP3-LSTEP)
C
C
C  Determine now RATIO such that YI = RATIO * XI  (I=1,2,3) holds
C  with minimal error.
C
      RATIO = ( X1*Y1 + X2*Y2 + X3*Y3 ) / ( X1*X1 + X2*X2 + X3*X3 )
      NLIM = NFIN - NSTEP2 + 1
C
      IF(ABS(RATIO).LT.ONE)   GO TO 211
C
      DO 210 N=1,NLIM
  210 SIXCOF(N) = RATIO * SIXCOF(N)
      SUMUNI = RATIO * RATIO * SUMFOR + SUMBAC
      GO TO 230
C
  211 NLIM = NLIM + 1
      RATIO = ONE / RATIO
      DO 212 N=NLIM,NFIN
  212 SIXCOF(N) = RATIO * SIXCOF(N)
      SUMUNI = SUMFOR + RATIO*RATIO*SUMBAC
      GO TO 230
C
  220 SUMUNI = SUM1
C
C
C  Normalize 6j coefficients
C
  230 CNORM = ONE / SQRT((L4+L4+ONE)*SUMUNI)
C
C  Sign convention for last 6j coefficient determines overall phase
C
      SIGN1 = SIGN(ONE,SIXCOF(NFIN))
      SIGN2 = (-ONE) ** INT(L2+L3+L5+L6+EPS)
      IF(SIGN1*SIGN2) 235,235,236
  235 CNORM = - CNORM
C
  236 IF(ABS(CNORM).LT.ONE)   GO TO 250
C
      DO 240 N=1,NFIN
  240 SIXCOF(N) = CNORM * SIXCOF(N)
      RETURN
C
  250 THRESH = TINY / ABS(CNORM)
      DO 251 N=1,NFIN
      IF(ABS(SIXCOF(N)).LT.THRESH)   SIXCOF(N) = ZERO
  251 SIXCOF(N) = CNORM * SIXCOF(N)
C
      RETURN
      END





C ===========================================================================
C =                             MODIFIED D1MACH                             =
C ===========================================================================
C	I modified D1MACH so that it works with a 64bit iMac running Max Os X Lion.
C   I guess this is pretty standard, in the sense that double precision numbers
C	have 16 digits of precision, 8 bytes, and go up to ~1e308.
*DECK D1MACH
      DOUBLE PRECISION FUNCTION D1MACH (I)
C***BEGIN PROLOGUE  D1MACH
C***PURPOSE  Return floating point machine dependent constants.
C***LIBRARY   SLATEC
C***CATEGORY  R1
C***TYPE      DOUBLE PRECISION (R1MACH-S, D1MACH-D)
C***KEYWORDS  MACHINE CONSTANTS
C***AUTHOR  Fox, P. A., (Bell Labs)
C           Hall, A. D., (Bell Labs)
C           Schryer, N. L., (Bell Labs)
C***DESCRIPTION
C
C   D1MACH can be used to obtain machine-dependent parameters for the
C   local machine environment.  It is a function subprogram with one
C   (input) argument, and can be referenced as follows:
C
C        D = D1MACH(I)
C
C   where I=1,...,5.  The (output) value of D above is determined by
C   the (input) value of I.  The results for various values of I are
C   discussed below.
C
C   D1MACH( 1) = B**(EMIN-1), the smallest positive magnitude.
C   D1MACH( 2) = B**EMAX*(1 - B**(-T)), the largest magnitude.
C   D1MACH( 3) = B**(-T), the smallest relative spacing.
C   D1MACH( 4) = B**(1-T), the largest relative spacing.
C   D1MACH( 5) = LOG10(B)
C
C   Assume double precision numbers are represented in the T-digit,
C   base-B form
C
C              sign (B**E)*( (X(1)/B) + ... + (X(T)/B**T) )
C
C   where 0 .LE. X(I) .LT. B for I=1,...,T, 0 .LT. X(1), and
C   EMIN .LE. E .LE. EMAX.
C
C   The values of B, T, EMIN and EMAX are provided in I1MACH as
C   follows:
C   I1MACH(10) = B, the base.
C   I1MACH(14) = T, the number of base-B digits.
C   I1MACH(15) = EMIN, the smallest exponent E.
C   I1MACH(16) = EMAX, the largest exponent E.
C
C   To alter this function for a particular environment, the desired
C   set of DATA statements should be activated by removing the C from
C   column 1.  Also, the values of D1MACH(1) - D1MACH(4) should be
C   checked for consistency with the local operating system.
C
C***REFERENCES  P. A. Fox, A. D. Hall and N. L. Schryer, Framework for
C                 a portable library, ACM Transactions on Mathematical
C                 Software 4, 2 (June 1978), pp. 177-188.
C***ROUTINES CALLED  XERMSG
C***REVISION HISTORY  (YYMMDD)
C   750101  DATE WRITTEN
C   890213  REVISION DATE from Version 3.2
C   891214  Prologue converted to Version 4.0 format.  (BAB)
C   900315  CALLs to XERROR changed to CALLs to XERMSG.  (THJ)
C   900618  Added DEC RISC constants.  (WRB)
C   900723  Added IBM RS 6000 constants.  (WRB)
C   900911  Added SUN 386i constants.  (WRB)
C   910710  Added HP 730 constants.  (SMR)
C   911114  Added Convex IEEE constants.  (WRB)
C   920121  Added SUN -r8 compiler option constants.  (WRB)
C   920229  Added Touchstone Delta i860 constants.  (WRB)
C   920501  Reformatted the REFERENCES section.  (WRB)
C   920625  Added CONVEX -p8 and -pd8 compiler option constants.
C           (BKS, WRB)
C   930201  Added DEC Alpha and SGI constants.  (RWC and WRB)
C***END PROLOGUE  D1MACH
C
C

	DOUBLE PRECISION DMACH(5)
	INTEGER I

C   Values for a 64bit iMac running Max Os X Lion - obtained from the F90
C   version of D1MACH that uses new builtin functions such as HUGE,
C   MINEXPONENT, DIGITS and RADIX
	DATA DMACH(1) / 2.22507D-308 /
	DATA DMACH(2) / 1.79769D+308 /
	DATA DMACH(3) / 1.11022D-16 /
	DATA DMACH(4) / 2.22045D-16 /
	DATA DMACH(5) / 0.30103D0 /

	IF ((I.GT.5) .or. (I.LT.1)) THEN
      WRITE (*, FMT = 9000)
9000     FORMAT ('1ERROR    1 IN D1MACH - I OUT OF BOUNDS')
      STOP
	END IF

	D1MACH = DMACH(I)
	RETURN
C
	END


C ================================================================
C =                       ORIGINAL D1MACH                        =
C ================================================================

C *DECK D1MACH
C       DOUBLE PRECISION FUNCTION D1MACH (I)
C C***BEGIN PROLOGUE  D1MACH
C C***PURPOSE  Return floating point machine dependent constants.
C C***LIBRARY   SLATEC
C C***CATEGORY  R1
C C***TYPE      DOUBLE PRECISION (R1MACH-S, D1MACH-D)
C C***KEYWORDS  MACHINE CONSTANTS
C C***AUTHOR  Fox, P. A., (Bell Labs)
C C           Hall, A. D., (Bell Labs)
C C           Schryer, N. L., (Bell Labs)
C C***DESCRIPTION
C C
C C   D1MACH can be used to obtain machine-dependent parameters for the
C C   local machine environment.  It is a function subprogram with one
C C   (input) argument, and can be referenced as follows:
C C
C C        D = D1MACH(I)
C C
C C   where I=1,...,5.  The (output) value of D above is determined by
C C   the (input) value of I.  The results for various values of I are
C C   discussed below.
C C
C C   D1MACH( 1) = B**(EMIN-1), the smallest positive magnitude.
C C   D1MACH( 2) = B**EMAX*(1 - B**(-T)), the largest magnitude.
C C   D1MACH( 3) = B**(-T), the smallest relative spacing.
C C   D1MACH( 4) = B**(1-T), the largest relative spacing.
C C   D1MACH( 5) = LOG10(B)
C C
C C   Assume double precision numbers are represented in the T-digit,
C C   base-B form
C C
C C              sign (B**E)*( (X(1)/B) + ... + (X(T)/B**T) )
C C
C C   where 0 .LE. X(I) .LT. B for I=1,...,T, 0 .LT. X(1), and
C C   EMIN .LE. E .LE. EMAX.
C C
C C   The values of B, T, EMIN and EMAX are provided in I1MACH as
C C   follows:
C C   I1MACH(10) = B, the base.
C C   I1MACH(14) = T, the number of base-B digits.
C C   I1MACH(15) = EMIN, the smallest exponent E.
C C   I1MACH(16) = EMAX, the largest exponent E.
C C
C C   To alter this function for a particular environment, the desired
C C   set of DATA statements should be activated by removing the C from
C C   column 1.  Also, the values of D1MACH(1) - D1MACH(4) should be
C C   checked for consistency with the local operating system.
C C
C C***REFERENCES  P. A. Fox, A. D. Hall and N. L. Schryer, Framework for
C C                 a portable library, ACM Transactions on Mathematical
C C                 Software 4, 2 (June 1978), pp. 177-188.
C C***ROUTINES CALLED  XERMSG
C C***REVISION HISTORY  (YYMMDD)
C C   750101  DATE WRITTEN
C C   890213  REVISION DATE from Version 3.2
C C   891214  Prologue converted to Version 4.0 format.  (BAB)
C C   900315  CALLs to XERROR changed to CALLs to XERMSG.  (THJ)
C C   900618  Added DEC RISC constants.  (WRB)
C C   900723  Added IBM RS 6000 constants.  (WRB)
C C   900911  Added SUN 386i constants.  (WRB)
C C   910710  Added HP 730 constants.  (SMR)
C C   911114  Added Convex IEEE constants.  (WRB)
C C   920121  Added SUN -r8 compiler option constants.  (WRB)
C C   920229  Added Touchstone Delta i860 constants.  (WRB)
C C   920501  Reformatted the REFERENCES section.  (WRB)
C C   920625  Added CONVEX -p8 and -pd8 compiler option constants.
C C           (BKS, WRB)
C C   930201  Added DEC Alpha and SGI constants.  (RWC and WRB)
C C***END PROLOGUE  D1MACH
C C
C       INTEGER SMALL(4)
C       INTEGER LARGE(4)
C       INTEGER RIGHT(4)
C       INTEGER DIVER(4)
C       INTEGER LOG10(4)
C C
C       DOUBLE PRECISION DMACH(5)
C       SAVE DMACH
C C
C       EQUIVALENCE (DMACH(1),SMALL(1))
C       EQUIVALENCE (DMACH(2),LARGE(1))
C       EQUIVALENCE (DMACH(3),RIGHT(1))
C       EQUIVALENCE (DMACH(4),DIVER(1))
C       EQUIVALENCE (DMACH(5),LOG10(1))
C C
C C     MACHINE CONSTANTS FOR THE AMIGA
C C     ABSOFT FORTRAN COMPILER USING THE 68020/68881 COMPILER OPTION
C C
C C     DATA SMALL(1), SMALL(2) / Z'00100000', Z'00000000' /
C C     DATA LARGE(1), LARGE(2) / Z'7FEFFFFF', Z'FFFFFFFF' /
C C     DATA RIGHT(1), RIGHT(2) / Z'3CA00000', Z'00000000' /
C C     DATA DIVER(1), DIVER(2) / Z'3CB00000', Z'00000000' /
C C     DATA LOG10(1), LOG10(2) / Z'3FD34413', Z'509F79FF' /
C C
C C     MACHINE CONSTANTS FOR THE AMIGA
C C     ABSOFT FORTRAN COMPILER USING SOFTWARE FLOATING POINT
C C
C C     DATA SMALL(1), SMALL(2) / Z'00100000', Z'00000000' /
C C     DATA LARGE(1), LARGE(2) / Z'7FDFFFFF', Z'FFFFFFFF' /
C C     DATA RIGHT(1), RIGHT(2) / Z'3CA00000', Z'00000000' /
C C     DATA DIVER(1), DIVER(2) / Z'3CB00000', Z'00000000' /
C C     DATA LOG10(1), LOG10(2) / Z'3FD34413', Z'509F79FF' /
C C
C C     MACHINE CONSTANTS FOR THE APOLLO
C C
C C     DATA SMALL(1), SMALL(2) / 16#00100000, 16#00000000 /
C C     DATA LARGE(1), LARGE(2) / 16#7FFFFFFF, 16#FFFFFFFF /
C C     DATA RIGHT(1), RIGHT(2) / 16#3CA00000, 16#00000000 /
C C     DATA DIVER(1), DIVER(2) / 16#3CB00000, 16#00000000 /
C C     DATA LOG10(1), LOG10(2) / 16#3FD34413, 16#509F79FF /
C C
C C     MACHINE CONSTANTS FOR THE BURROUGHS 1700 SYSTEM
C C
C C     DATA SMALL(1) / ZC00800000 /
C C     DATA SMALL(2) / Z000000000 /
C C     DATA LARGE(1) / ZDFFFFFFFF /
C C     DATA LARGE(2) / ZFFFFFFFFF /
C C     DATA RIGHT(1) / ZCC5800000 /
C C     DATA RIGHT(2) / Z000000000 /
C C     DATA DIVER(1) / ZCC6800000 /
C C     DATA DIVER(2) / Z000000000 /
C C     DATA LOG10(1) / ZD00E730E7 /
C C     DATA LOG10(2) / ZC77800DC0 /
C C
C C     MACHINE CONSTANTS FOR THE BURROUGHS 5700 SYSTEM
C C
C C     DATA SMALL(1) / O1771000000000000 /
C C     DATA SMALL(2) / O0000000000000000 /
C C     DATA LARGE(1) / O0777777777777777 /
C C     DATA LARGE(2) / O0007777777777777 /
C C     DATA RIGHT(1) / O1461000000000000 /
C C     DATA RIGHT(2) / O0000000000000000 /
C C     DATA DIVER(1) / O1451000000000000 /
C C     DATA DIVER(2) / O0000000000000000 /
C C     DATA LOG10(1) / O1157163034761674 /
C C     DATA LOG10(2) / O0006677466732724 /
C C
C C     MACHINE CONSTANTS FOR THE BURROUGHS 6700/7700 SYSTEMS
C C
C C     DATA SMALL(1) / O1771000000000000 /
C C     DATA SMALL(2) / O7770000000000000 /
C C     DATA LARGE(1) / O0777777777777777 /
C C     DATA LARGE(2) / O7777777777777777 /
C C     DATA RIGHT(1) / O1461000000000000 /
C C     DATA RIGHT(2) / O0000000000000000 /
C C     DATA DIVER(1) / O1451000000000000 /
C C     DATA DIVER(2) / O0000000000000000 /
C C     DATA LOG10(1) / O1157163034761674 /
C C     DATA LOG10(2) / O0006677466732724 /
C C
C C     MACHINE CONSTANTS FOR THE CDC 170/180 SERIES USING NOS/VE
C C
C C     DATA SMALL(1) / Z"3001800000000000" /
C C     DATA SMALL(2) / Z"3001000000000000" /
C C     DATA LARGE(1) / Z"4FFEFFFFFFFFFFFE" /
C C     DATA LARGE(2) / Z"4FFE000000000000" /
C C     DATA RIGHT(1) / Z"3FD2800000000000" /
C C     DATA RIGHT(2) / Z"3FD2000000000000" /
C C     DATA DIVER(1) / Z"3FD3800000000000" /
C C     DATA DIVER(2) / Z"3FD3000000000000" /
C C     DATA LOG10(1) / Z"3FFF9A209A84FBCF" /
C C     DATA LOG10(2) / Z"3FFFF7988F8959AC" /
C C
C C     MACHINE CONSTANTS FOR THE CDC 6000/7000 SERIES
C C
C C     DATA SMALL(1) / 00564000000000000000B /
C C     DATA SMALL(2) / 00000000000000000000B /
C C     DATA LARGE(1) / 37757777777777777777B /
C C     DATA LARGE(2) / 37157777777777777777B /
C C     DATA RIGHT(1) / 15624000000000000000B /
C C     DATA RIGHT(2) / 00000000000000000000B /
C C     DATA DIVER(1) / 15634000000000000000B /
C C     DATA DIVER(2) / 00000000000000000000B /
C C     DATA LOG10(1) / 17164642023241175717B /
C C     DATA LOG10(2) / 16367571421742254654B /
C C
C C     MACHINE CONSTANTS FOR THE CELERITY C1260
C C
C C     DATA SMALL(1), SMALL(2) / Z'00100000', Z'00000000' /
C C     DATA LARGE(1), LARGE(2) / Z'7FEFFFFF', Z'FFFFFFFF' /
C C     DATA RIGHT(1), RIGHT(2) / Z'3CA00000', Z'00000000' /
C C     DATA DIVER(1), DIVER(2) / Z'3CB00000', Z'00000000' /
C C     DATA LOG10(1), LOG10(2) / Z'3FD34413', Z'509F79FF' /
C C
C C     MACHINE CONSTANTS FOR THE CONVEX
C C     USING THE -fn OR -pd8 COMPILER OPTION
C C
C C     DATA DMACH(1) / Z'0010000000000000' /
C C     DATA DMACH(2) / Z'7FFFFFFFFFFFFFFF' /
C C     DATA DMACH(3) / Z'3CC0000000000000' /
C C     DATA DMACH(4) / Z'3CD0000000000000' /
C C     DATA DMACH(5) / Z'3FF34413509F79FF' /
C C
C C     MACHINE CONSTANTS FOR THE CONVEX
C C     USING THE -fi COMPILER OPTION
C C
C C     DATA DMACH(1) / Z'0010000000000000' /
C C     DATA DMACH(2) / Z'7FEFFFFFFFFFFFFF' /
C C     DATA DMACH(3) / Z'3CA0000000000000' /
C C     DATA DMACH(4) / Z'3CB0000000000000' /
C C     DATA DMACH(5) / Z'3FD34413509F79FF' /
C C
C C     MACHINE CONSTANTS FOR THE CONVEX
C C     USING THE -p8 COMPILER OPTION
C C
C C     DATA DMACH(1) / Z'00010000000000000000000000000000' /
C C     DATA DMACH(2) / Z'7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF' /
C C     DATA DMACH(3) / Z'3F900000000000000000000000000000' /
C C     DATA DMACH(4) / Z'3F910000000000000000000000000000' /
C C     DATA DMACH(5) / Z'3FFF34413509F79FEF311F12B35816F9' /
C C
C C     MACHINE CONSTANTS FOR THE CRAY
C C
C C     DATA SMALL(1) / 201354000000000000000B /
C C     DATA SMALL(2) / 000000000000000000000B /
C C     DATA LARGE(1) / 577767777777777777777B /
C C     DATA LARGE(2) / 000007777777777777774B /
C C     DATA RIGHT(1) / 376434000000000000000B /
C C     DATA RIGHT(2) / 000000000000000000000B /
C C     DATA DIVER(1) / 376444000000000000000B /
C C     DATA DIVER(2) / 000000000000000000000B /
C C     DATA LOG10(1) / 377774642023241175717B /
C C     DATA LOG10(2) / 000007571421742254654B /
C C
C C     MACHINE CONSTANTS FOR THE DATA GENERAL ECLIPSE S/200
C C     NOTE - IT MAY BE APPROPRIATE TO INCLUDE THE FOLLOWING CARD -
C C     STATIC DMACH(5)
C C
C C     DATA SMALL /    20K, 3*0 /
C C     DATA LARGE / 77777K, 3*177777K /
C C     DATA RIGHT / 31420K, 3*0 /
C C     DATA DIVER / 32020K, 3*0 /
C C     DATA LOG10 / 40423K, 42023K, 50237K, 74776K /
C C
C C     MACHINE CONSTANTS FOR THE DEC ALPHA
C C     USING G_FLOAT
C C
C C     DATA DMACH(1) / '0000000000000010'X /
C C     DATA DMACH(2) / 'FFFFFFFFFFFF7FFF'X /
C C     DATA DMACH(3) / '0000000000003CC0'X /
C C     DATA DMACH(4) / '0000000000003CD0'X /
C C     DATA DMACH(5) / '79FF509F44133FF3'X /
C C
C C     MACHINE CONSTANTS FOR THE DEC ALPHA
C C     USING IEEE_FORMAT
C C
C C     DATA DMACH(1) / '0010000000000000'X /
C C     DATA DMACH(2) / '7FEFFFFFFFFFFFFF'X /
C C     DATA DMACH(3) / '3CA0000000000000'X /
C C     DATA DMACH(4) / '3CB0000000000000'X /
C C     DATA DMACH(5) / '3FD34413509F79FF'X /
C C
C C     MACHINE CONSTANTS FOR THE DEC RISC
C C
C C     DATA SMALL(1), SMALL(2) / Z'00000000', Z'00100000'/
C C     DATA LARGE(1), LARGE(2) / Z'FFFFFFFF', Z'7FEFFFFF'/
C C     DATA RIGHT(1), RIGHT(2) / Z'00000000', Z'3CA00000'/
C C     DATA DIVER(1), DIVER(2) / Z'00000000', Z'3CB00000'/
C C     DATA LOG10(1), LOG10(2) / Z'509F79FF', Z'3FD34413'/
C C
C C     MACHINE CONSTANTS FOR THE DEC VAX
C C     USING D_FLOATING
C C     (EXPRESSED IN INTEGER AND HEXADECIMAL)
C C     THE HEX FORMAT BELOW MAY NOT BE SUITABLE FOR UNIX SYSTEMS
C C     THE INTEGER FORMAT SHOULD BE OK FOR UNIX SYSTEMS
C C
C C     DATA SMALL(1), SMALL(2) /        128,           0 /
C C     DATA LARGE(1), LARGE(2) /     -32769,          -1 /
C C     DATA RIGHT(1), RIGHT(2) /       9344,           0 /
C C     DATA DIVER(1), DIVER(2) /       9472,           0 /
C C     DATA LOG10(1), LOG10(2) /  546979738,  -805796613 /
C C
C C     DATA SMALL(1), SMALL(2) / Z00000080, Z00000000 /
C C     DATA LARGE(1), LARGE(2) / ZFFFF7FFF, ZFFFFFFFF /
C C     DATA RIGHT(1), RIGHT(2) / Z00002480, Z00000000 /
C C     DATA DIVER(1), DIVER(2) / Z00002500, Z00000000 /
C C     DATA LOG10(1), LOG10(2) / Z209A3F9A, ZCFF884FB /
C C
C C     MACHINE CONSTANTS FOR THE DEC VAX
C C     USING G_FLOATING
C C     (EXPRESSED IN INTEGER AND HEXADECIMAL)
C C     THE HEX FORMAT BELOW MAY NOT BE SUITABLE FOR UNIX SYSTEMS
C C     THE INTEGER FORMAT SHOULD BE OK FOR UNIX SYSTEMS
C C
C C     DATA SMALL(1), SMALL(2) /         16,           0 /
C C     DATA LARGE(1), LARGE(2) /     -32769,          -1 /
C C     DATA RIGHT(1), RIGHT(2) /      15552,           0 /
C C     DATA DIVER(1), DIVER(2) /      15568,           0 /
C C     DATA LOG10(1), LOG10(2) /  1142112243, 2046775455 /
C C
C C     DATA SMALL(1), SMALL(2) / Z00000010, Z00000000 /
C C     DATA LARGE(1), LARGE(2) / ZFFFF7FFF, ZFFFFFFFF /
C C     DATA RIGHT(1), RIGHT(2) / Z00003CC0, Z00000000 /
C C     DATA DIVER(1), DIVER(2) / Z00003CD0, Z00000000 /
C C     DATA LOG10(1), LOG10(2) / Z44133FF3, Z79FF509F /
C C
C C     MACHINE CONSTANTS FOR THE ELXSI 6400
C C     (ASSUMING REAL*8 IS THE DEFAULT DOUBLE PRECISION)
C C
C C     DATA SMALL(1), SMALL(2) / '00100000'X,'00000000'X /
C C     DATA LARGE(1), LARGE(2) / '7FEFFFFF'X,'FFFFFFFF'X /
C C     DATA RIGHT(1), RIGHT(2) / '3CB00000'X,'00000000'X /
C C     DATA DIVER(1), DIVER(2) / '3CC00000'X,'00000000'X /
C C     DATA LOG10(1), LOG10(2) / '3FD34413'X,'509F79FF'X /
C C
C C     MACHINE CONSTANTS FOR THE HARRIS 220
C C
C C     DATA SMALL(1), SMALL(2) / '20000000, '00000201 /
C C     DATA LARGE(1), LARGE(2) / '37777777, '37777577 /
C C     DATA RIGHT(1), RIGHT(2) / '20000000, '00000333 /
C C     DATA DIVER(1), DIVER(2) / '20000000, '00000334 /
C C     DATA LOG10(1), LOG10(2) / '23210115, '10237777 /
C C
C C     MACHINE CONSTANTS FOR THE HONEYWELL 600/6000 SERIES
C C
C C     DATA SMALL(1), SMALL(2) / O402400000000, O000000000000 /
C C     DATA LARGE(1), LARGE(2) / O376777777777, O777777777777 /
C C     DATA RIGHT(1), RIGHT(2) / O604400000000, O000000000000 /
C C     DATA DIVER(1), DIVER(2) / O606400000000, O000000000000 /
C C     DATA LOG10(1), LOG10(2) / O776464202324, O117571775714 /
C C
C C     MACHINE CONSTANTS FOR THE HP 730
C C
C C     DATA DMACH(1) / Z'0010000000000000' /
C C     DATA DMACH(2) / Z'7FEFFFFFFFFFFFFF' /
C C     DATA DMACH(3) / Z'3CA0000000000000' /
C C     DATA DMACH(4) / Z'3CB0000000000000' /
C C     DATA DMACH(5) / Z'3FD34413509F79FF' /
C C
C C     MACHINE CONSTANTS FOR THE HP 2100
C C     THREE WORD DOUBLE PRECISION OPTION WITH FTN4
C C
C C     DATA SMALL(1), SMALL(2), SMALL(3) / 40000B,       0,       1 /
C C     DATA LARGE(1), LARGE(2), LARGE(3) / 77777B, 177777B, 177776B /
C C     DATA RIGHT(1), RIGHT(2), RIGHT(3) / 40000B,       0,    265B /
C C     DATA DIVER(1), DIVER(2), DIVER(3) / 40000B,       0,    276B /
C C     DATA LOG10(1), LOG10(2), LOG10(3) / 46420B,  46502B,  77777B /
C C
C C     MACHINE CONSTANTS FOR THE HP 2100
C C     FOUR WORD DOUBLE PRECISION OPTION WITH FTN4
C C
C C     DATA SMALL(1), SMALL(2) /  40000B,       0 /
C C     DATA SMALL(3), SMALL(4) /       0,       1 /
C C     DATA LARGE(1), LARGE(2) /  77777B, 177777B /
C C     DATA LARGE(3), LARGE(4) / 177777B, 177776B /
C C     DATA RIGHT(1), RIGHT(2) /  40000B,       0 /
C C     DATA RIGHT(3), RIGHT(4) /       0,    225B /
C C     DATA DIVER(1), DIVER(2) /  40000B,       0 /
C C     DATA DIVER(3), DIVER(4) /       0,    227B /
C C     DATA LOG10(1), LOG10(2) /  46420B,  46502B /
C C     DATA LOG10(3), LOG10(4) /  76747B, 176377B /
C C
C C     MACHINE CONSTANTS FOR THE HP 9000
C C
C C     DATA SMALL(1), SMALL(2) / 00040000000B, 00000000000B /
C C     DATA LARGE(1), LARGE(2) / 17737777777B, 37777777777B /
C C     DATA RIGHT(1), RIGHT(2) / 07454000000B, 00000000000B /
C C     DATA DIVER(1), DIVER(2) / 07460000000B, 00000000000B /
C C     DATA LOG10(1), LOG10(2) / 07764642023B, 12047674777B /
C C
C C     MACHINE CONSTANTS FOR THE IBM 360/370 SERIES,
C C     THE XEROX SIGMA 5/7/9, THE SEL SYSTEMS 85/86, AND
C C     THE PERKIN ELMER (INTERDATA) 7/32.
C C
C C     DATA SMALL(1), SMALL(2) / Z00100000, Z00000000 /
C C     DATA LARGE(1), LARGE(2) / Z7FFFFFFF, ZFFFFFFFF /
C C     DATA RIGHT(1), RIGHT(2) / Z33100000, Z00000000 /
C C     DATA DIVER(1), DIVER(2) / Z34100000, Z00000000 /
C C     DATA LOG10(1), LOG10(2) / Z41134413, Z509F79FF /
C C
C C     MACHINE CONSTANTS FOR THE IBM PC
C C     ASSUMES THAT ALL ARITHMETIC IS DONE IN DOUBLE PRECISION
C C     ON 8088, I.E., NOT IN 80 BIT FORM FOR THE 8087.
C C
C C     DATA SMALL(1) / 2.23D-308  /
C C     DATA LARGE(1) / 1.79D+308  /
C C     DATA RIGHT(1) / 1.11D-16   /
C C     DATA DIVER(1) / 2.22D-16   /
C C     DATA LOG10(1) / 0.301029995663981195D0 /
C C
C C     MACHINE CONSTANTS FOR THE IBM RS 6000
C C
C C     DATA DMACH(1) / Z'0010000000000000' /
C C     DATA DMACH(2) / Z'7FEFFFFFFFFFFFFF' /
C C     DATA DMACH(3) / Z'3CA0000000000000' /
C C     DATA DMACH(4) / Z'3CB0000000000000' /
C C     DATA DMACH(5) / Z'3FD34413509F79FF' /
C C
C C     MACHINE CONSTANTS FOR THE INTEL i860
C C
C C     DATA DMACH(1) / Z'0010000000000000' /
C C     DATA DMACH(2) / Z'7FEFFFFFFFFFFFFF' /
C C     DATA DMACH(3) / Z'3CA0000000000000' /
C C     DATA DMACH(4) / Z'3CB0000000000000' /
C C     DATA DMACH(5) / Z'3FD34413509F79FF' /
C C
C C     MACHINE CONSTANTS FOR THE PDP-10 (KA PROCESSOR)
C C
C C     DATA SMALL(1), SMALL(2) / "033400000000, "000000000000 /
C C     DATA LARGE(1), LARGE(2) / "377777777777, "344777777777 /
C C     DATA RIGHT(1), RIGHT(2) / "113400000000, "000000000000 /
C C     DATA DIVER(1), DIVER(2) / "114400000000, "000000000000 /
C C     DATA LOG10(1), LOG10(2) / "177464202324, "144117571776 /
C C
C C     MACHINE CONSTANTS FOR THE PDP-10 (KI PROCESSOR)
C C
C C     DATA SMALL(1), SMALL(2) / "000400000000, "000000000000 /
C C     DATA LARGE(1), LARGE(2) / "377777777777, "377777777777 /
C C     DATA RIGHT(1), RIGHT(2) / "103400000000, "000000000000 /
C C     DATA DIVER(1), DIVER(2) / "104400000000, "000000000000 /
C C     DATA LOG10(1), LOG10(2) / "177464202324, "476747767461 /
C C
C C     MACHINE CONSTANTS FOR PDP-11 FORTRAN SUPPORTING
C C     32-BIT INTEGERS (EXPRESSED IN INTEGER AND OCTAL).
C C
C C     DATA SMALL(1), SMALL(2) /    8388608,           0 /
C C     DATA LARGE(1), LARGE(2) / 2147483647,          -1 /
C C     DATA RIGHT(1), RIGHT(2) /  612368384,           0 /
C C     DATA DIVER(1), DIVER(2) /  620756992,           0 /
C C     DATA LOG10(1), LOG10(2) / 1067065498, -2063872008 /
C C
C C     DATA SMALL(1), SMALL(2) / O00040000000, O00000000000 /
C C     DATA LARGE(1), LARGE(2) / O17777777777, O37777777777 /
C C     DATA RIGHT(1), RIGHT(2) / O04440000000, O00000000000 /
C C     DATA DIVER(1), DIVER(2) / O04500000000, O00000000000 /
C C     DATA LOG10(1), LOG10(2) / O07746420232, O20476747770 /
C C
C C     MACHINE CONSTANTS FOR PDP-11 FORTRAN SUPPORTING
C C     16-BIT INTEGERS (EXPRESSED IN INTEGER AND OCTAL).
C C
C C     DATA SMALL(1), SMALL(2) /    128,      0 /
C C     DATA SMALL(3), SMALL(4) /      0,      0 /
C C     DATA LARGE(1), LARGE(2) /  32767,     -1 /
C C     DATA LARGE(3), LARGE(4) /     -1,     -1 /
C C     DATA RIGHT(1), RIGHT(2) /   9344,      0 /
C C     DATA RIGHT(3), RIGHT(4) /      0,      0 /
C C     DATA DIVER(1), DIVER(2) /   9472,      0 /
C C     DATA DIVER(3), DIVER(4) /      0,      0 /
C C     DATA LOG10(1), LOG10(2) /  16282,   8346 /
C C     DATA LOG10(3), LOG10(4) / -31493, -12296 /
C C
C C     DATA SMALL(1), SMALL(2) / O000200, O000000 /
C C     DATA SMALL(3), SMALL(4) / O000000, O000000 /
C C     DATA LARGE(1), LARGE(2) / O077777, O177777 /
C C     DATA LARGE(3), LARGE(4) / O177777, O177777 /
C C     DATA RIGHT(1), RIGHT(2) / O022200, O000000 /
C C     DATA RIGHT(3), RIGHT(4) / O000000, O000000 /
C C     DATA DIVER(1), DIVER(2) / O022400, O000000 /
C C     DATA DIVER(3), DIVER(4) / O000000, O000000 /
C C     DATA LOG10(1), LOG10(2) / O037632, O020232 /
C C     DATA LOG10(3), LOG10(4) / O102373, O147770 /
C C
C C     MACHINE CONSTANTS FOR THE SILICON GRAPHICS
C C
C C     DATA SMALL(1), SMALL(2) / Z'00100000', Z'00000000' /
C C     DATA LARGE(1), LARGE(2) / Z'7FEFFFFF', Z'FFFFFFFF' /
C C     DATA RIGHT(1), RIGHT(2) / Z'3CA00000', Z'00000000' /
C C     DATA DIVER(1), DIVER(2) / Z'3CB00000', Z'00000000' /
C C     DATA LOG10(1), LOG10(2) / Z'3FD34413', Z'509F79FF' /
C C
C C     MACHINE CONSTANTS FOR THE SUN
C C
C C     DATA DMACH(1) / Z'0010000000000000' /
C C     DATA DMACH(2) / Z'7FEFFFFFFFFFFFFF' /
C C     DATA DMACH(3) / Z'3CA0000000000000' /
C C     DATA DMACH(4) / Z'3CB0000000000000' /
C C     DATA DMACH(5) / Z'3FD34413509F79FF' /
C C
C C     MACHINE CONSTANTS FOR THE SUN
C C     USING THE -r8 COMPILER OPTION
C C
C C     DATA DMACH(1) / Z'00010000000000000000000000000000' /
C C     DATA DMACH(2) / Z'7FFEFFFFFFFFFFFFFFFFFFFFFFFFFFFF' /
C C     DATA DMACH(3) / Z'3F8E0000000000000000000000000000' /
C C     DATA DMACH(4) / Z'3F8F0000000000000000000000000000' /
C C     DATA DMACH(5) / Z'3FFD34413509F79FEF311F12B35816F9' /
C C
C C     MACHINE CONSTANTS FOR THE SUN 386i
C C
C C     DATA SMALL(1), SMALL(2) / Z'FFFFFFFD', Z'000FFFFF' /
C C     DATA LARGE(1), LARGE(2) / Z'FFFFFFB0', Z'7FEFFFFF' /
C C     DATA RIGHT(1), RIGHT(2) / Z'000000B0', Z'3CA00000' /
C C     DATA DIVER(1), DIVER(2) / Z'FFFFFFCB', Z'3CAFFFFF'
C C     DATA LOG10(1), LOG10(2) / Z'509F79E9', Z'3FD34413' /
C C
C C     MACHINE CONSTANTS FOR THE UNIVAC 1100 SERIES FTN COMPILER
C C
C C     DATA SMALL(1), SMALL(2) / O000040000000, O000000000000 /
C C     DATA LARGE(1), LARGE(2) / O377777777777, O777777777777 /
C C     DATA RIGHT(1), RIGHT(2) / O170540000000, O000000000000 /
C C     DATA DIVER(1), DIVER(2) / O170640000000, O000000000000 /
C C     DATA LOG10(1), LOG10(2) / O177746420232, O411757177572 /
C C
C C***FIRST EXECUTABLE STATEMENT  D1MACH
C       IF (I .LT. 1 .OR. I .GT. 5) CALL XERMSG ('SLATEC', 'D1MACH',
C      +   'I OUT OF BOUNDS', 1, 2)
C C
C       D1MACH = DMACH(I)
C       RETURN
C C
C       END

